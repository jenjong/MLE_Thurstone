j_k = j_k + 1
j_c = j_c + 1
j_c>p
IX
ix
j = 3
m = mu_e[j]- sum(Omg_e[j,][-j]*(z[-j] - mu_e[-j]))/Omg_e[j,j]
m
v = sqrt(1/Omg_e[j,j])
v
j
j_c
if (j_c == 1) b = Inf else b = z[ix[j_c-1]]
b
j_c+1
ix[j_c+1]
z
if (j_c == p) a = -Inf else a = z[ix[j_c+1]]
tz = rtruncnorm(1, a=a, b=b, mean = m, sd = v)
z[j] = tz
tz
z[j]
z
ix
sort(z, index.return = T)
x
sort(z, index.return = T, decreasing = T)
sort(z, index.return = T, decreasing = T)$ix
tmp == ix
tmp = sort(z, index.return = T, decreasing = T)$ix
tmp == ix
( sum(tmp == ix)!=p)
rm(list = ls()); gc()
library(MASS)
if (!require(truncnorm)) {install.packages("truncnorm") ; library(truncnorm)}
p = 5
mu = seq(5,0, length = p)
Sigma = diag(1,p)
n = 100
set.seed(1)
z = mvrnorm(n, mu, Sigma)
# pi_mat denotes the ranks of items
pi_mat =t(apply(z, 1, order, decreasing = T))
# ranking index
rank_index_t = c("", n)
for (i in 1:n)
{
x = pi_mat[i,]
if (p<10)
{
xt = as.character(x)
rank_index_t[i] = paste(xt,sep='',collapse = "")
}
if (p>=10)
{
xt = x
idx = (nchar(xt)==1)
xt[idx] = paste0("0",xt[idx])
rank_index_t[i] = paste(xt,sep='',collapse = "")
}
}
rank_index_t = factor(rank_index_t)
rank_id = levels(rank_index_t)
rank_index = as.integer(rank_index_t)
# initialization:: pairwise comparisons (package)
mu_e = seq(5,0, length = p)
Sig_e = diag(1,p)
Omg_e = solve(Sig_e)
# sampling
i = 9 ; length(rank_id)
idx = which(rank_index == i)
x = pi_mat[idx[1],]
# set an initial of z
while(T)
{
z = mvrnorm(1, mu_e, Sig_e)
zo = order(z, decreasing = T)
if (!any(x != zo)) break
}
burn_num = 1e+4
restore_num = 5e+3
# burning
# ix[j_c] : the index of item with rank j_c
# iterates according to ranks (j_c from 1 to p)
j_c = 1
ix = sort(x, index.return = T)$ix
for (j in rep(ix, burn_num))
{
m = mu_e[j]- sum(Omg_e[j,][-j]*(z[-j] - mu_e[-j]))/Omg_e[j,j]
v = sqrt(1/Omg_e[j,j])
if (j_c == 1) b = Inf else b = z[ix[j_c-1]]
if (j_c == p) a = -Inf else a = z[ix[j_c+1]]
z[j] = rtruncnorm(1, a=a, b=b, mean = m, sd = v)
j_c = j_c + 1
if (j_c>p) j_c = 1
}
# restore
z_tmp = rep(0, p*restore_num)
j_k = 1
j_c = 1
for (j in rep(ix, restore_num))
{
m = mu_e[j]- sum(Omg_e[j,][-j]*(z[-j] - mu_e[-j]))/Omg_e[j,j]
v = sqrt(1/Omg_e[j,j])
if (j_c == 1) b = Inf else b = z[ix[j_c-1]]
if (j_c == p) a = -Inf else a = z[ix[j_c+1]]
tz = rtruncnorm(1, a=a, b=b, mean = m, sd = v)
z[j] = tz
tmp = sort(z, index.return = T, decreasing = T)$ix
if ( sum(tmp == ix)!=p) break
z_tmp[j_k]  = tz
j_k = j_k + 1
j_c = j_c + 1
if (j_c>p) j_c = 1
}
z
j
ix
z_tmp[1:5]
j_k
j_k = 1
j_c = 1
zmat = matrix(0, restore_num, p)
rm(list = ls()); gc()
library(MASS)
if (!require(truncnorm)) {install.packages("truncnorm") ; library(truncnorm)}
p = 5
mu = seq(5,0, length = p)
Sigma = diag(1,p)
n = 100
set.seed(1)
z = mvrnorm(n, mu, Sigma)
# pi_mat denotes the ranks of items
pi_mat =t(apply(z, 1, order, decreasing = T))
# ranking index
rank_index_t = c("", n)
for (i in 1:n)
{
x = pi_mat[i,]
if (p<10)
{
xt = as.character(x)
rank_index_t[i] = paste(xt,sep='',collapse = "")
}
if (p>=10)
{
xt = x
idx = (nchar(xt)==1)
xt[idx] = paste0("0",xt[idx])
rank_index_t[i] = paste(xt,sep='',collapse = "")
}
}
rank_index_t = factor(rank_index_t)
rank_id = levels(rank_index_t)
rank_index = as.integer(rank_index_t)
# initialization:: pairwise comparisons (package)
mu_e = seq(5,0, length = p)
Sig_e = diag(1,p)
Omg_e = solve(Sig_e)
# sampling
i = 9 ; length(rank_id)
idx = which(rank_index == i)
x = pi_mat[idx[1],]
# set an initial of z
while(T)
{
z = mvrnorm(1, mu_e, Sig_e)
zo = order(z, decreasing = T)
if (!any(x != zo)) break
}
burn_num = 1e+4
restore_num = 5e+3
# burning
# ix[j_c] : the index of item with rank j_c
# iterates according to ranks (j_c from 1 to p)
j_c = 1
ix = sort(x, index.return = T)$ix
for (j in rep(ix, burn_num))
{
m = mu_e[j]- sum(Omg_e[j,][-j]*(z[-j] - mu_e[-j]))/Omg_e[j,j]
v = sqrt(1/Omg_e[j,j])
if (j_c == 1) b = Inf else b = z[ix[j_c-1]]
if (j_c == p) a = -Inf else a = z[ix[j_c+1]]
z[j] = rtruncnorm(1, a=a, b=b, mean = m, sd = v)
j_c = j_c + 1
if (j_c>p) j_c = 1
}
z
j_k = 1
j_c = 1
zmat = matrix(0, restore_num, p)
for (j in rep(ix, restore_num))
{
m = mu_e[j]- sum(Omg_e[j,][-j]*(z[-j] - mu_e[-j]))/Omg_e[j,j]
v = sqrt(1/Omg_e[j,j])
if (j_c == 1) b = Inf else b = z[ix[j_c-1]]
if (j_c == p) a = -Inf else a = z[ix[j_c+1]]
tz = rtruncnorm(1, a=a, b=b, mean = m, sd = v)
z[j] = tz
j_c = j_c + 1
if (j_c>p)
{
zmat[j_k,] = z
j_c = 1
j_k = j_k + 1
}
}
colMeans(zmat)
boxplot(zmat)
ix
rm(list = ls()); gc()
library(MASS)
if (!require(truncnorm)) {install.packages("truncnorm") ; library(truncnorm)}
p = 5
mu = seq(5,0, length = p)
Sigma = diag(1,p)
n = 100
set.seed(1)
z = mvrnorm(n, mu, Sigma)
# pi_mat denotes the ranks of items
pi_mat =t(apply(z, 1, order, decreasing = T))
# ranking index
rank_index_t = c("", n)
for (i in 1:n)
{
x = pi_mat[i,]
if (p<10)
{
xt = as.character(x)
rank_index_t[i] = paste(xt,sep='',collapse = "")
}
if (p>=10)
{
xt = x
idx = (nchar(xt)==1)
xt[idx] = paste0("0",xt[idx])
rank_index_t[i] = paste(xt,sep='',collapse = "")
}
}
rank_index_t = factor(rank_index_t)
rank_id = levels(rank_index_t)
rank_index = as.integer(rank_index_t)
# initialization:: pairwise comparisons (package)
mu_e = seq(5,0, length = p)
Sig_e = diag(1,p)
Omg_e = solve(Sig_e)
# sampling
i = 9 ; length(rank_id)
idx = which(rank_index == i)
x = pi_mat[idx[1],]
# set an initial of z
while(T)
{
z = mvrnorm(1, mu_e, Sig_e)
zo = order(z, decreasing = T)
if (!any(x != zo))
{
if (verbose) cat("Initialization is complete! ")
break
}
}
rm(list = ls()); gc()
library(MASS)
if (!require(truncnorm)) {install.packages("truncnorm") ; library(truncnorm)}
p = 5
mu = seq(5,0, length = p)
Sigma = diag(1,p)
n = 100
verbose = T
set.seed(1)
z = mvrnorm(n, mu, Sigma)
# pi_mat denotes the ranks of items
pi_mat =t(apply(z, 1, order, decreasing = T))
# ranking index
rank_index_t = c("", n)
for (i in 1:n)
{
x = pi_mat[i,]
if (p<10)
{
xt = as.character(x)
rank_index_t[i] = paste(xt,sep='',collapse = "")
}
if (p>=10)
{
xt = x
idx = (nchar(xt)==1)
xt[idx] = paste0("0",xt[idx])
rank_index_t[i] = paste(xt,sep='',collapse = "")
}
}
rank_index_t = factor(rank_index_t)
rank_id = levels(rank_index_t)
rank_index = as.integer(rank_index_t)
# initialization:: pairwise comparisons (package)
mu_e = seq(5,0, length = p)
Sig_e = diag(1,p)
Omg_e = solve(Sig_e)
# sampling
i = 9 ; length(rank_id)
idx = which(rank_index == i)
x = pi_mat[idx[1],]
# set an initial of z
while(T)
{
z = mvrnorm(1, mu_e, Sig_e)
zo = order(z, decreasing = T)
if (!any(x != zo))
{
if (verbose) cat("Initialization is complete! ")
break
}
}
burn_num = 1e+4
restore_num = 5e+3
# burning
# ix[j_c] : the index of item with rank j_c
# iterates according to ranks (j_c from 1 to p)
j_c = 1
ix = sort(x, index.return = T)$ix
for (j in rep(ix, burn_num))
{
m = mu_e[j]- sum(Omg_e[j,][-j]*(z[-j] - mu_e[-j]))/Omg_e[j,j]
v = sqrt(1/Omg_e[j,j])
if (j_c == 1) b = Inf else b = z[ix[j_c-1]]
if (j_c == p) a = -Inf else a = z[ix[j_c+1]]
z[j] = rtruncnorm(1, a=a, b=b, mean = m, sd = v)
j_c = j_c + 1
if (j_c>p) j_c = 1
}
# restore
j_k = 1
j_c = 1
zmat = matrix(0, restore_num, p)
for (j in rep(ix, restore_num))
{
m = mu_e[j]- sum(Omg_e[j,][-j]*(z[-j] - mu_e[-j]))/Omg_e[j,j]
v = sqrt(1/Omg_e[j,j])
if (j_c == 1) b = Inf else b = z[ix[j_c-1]]
if (j_c == p) a = -Inf else a = z[ix[j_c+1]]
tz = rtruncnorm(1, a=a, b=b, mean = m, sd = v)
z[j] = tz
j_c = j_c + 1
if (j_c>p)
{
zmat[j_k,] = z
j_c = 1
j_k = j_k + 1
}
}
colMeans(zmat)
i = 1 ; length(rank_id)
idx = which(rank_index == i)
x = pi_mat[idx[1],]
# set an initial of z
while(T)
{
z = mvrnorm(1, mu_e, Sig_e)
zo = order(z, decreasing = T)
if (!any(x != zo))
{
if (verbose) cat("Initialization is complete! ")
break
}
}
burn_num = 1e+4
restore_num = 5e+3
# burning
# ix[j_c] : the index of item with rank j_c
# iterates according to ranks (j_c from 1 to p)
j_c = 1
ix = sort(x, index.return = T)$ix
for (j in rep(ix, burn_num))
{
m = mu_e[j]- sum(Omg_e[j,][-j]*(z[-j] - mu_e[-j]))/Omg_e[j,j]
v = sqrt(1/Omg_e[j,j])
if (j_c == 1) b = Inf else b = z[ix[j_c-1]]
if (j_c == p) a = -Inf else a = z[ix[j_c+1]]
z[j] = rtruncnorm(1, a=a, b=b, mean = m, sd = v)
j_c = j_c + 1
if (j_c>p) j_c = 1
}
# restore
j_k = 1
j_c = 1
zmat = matrix(0, restore_num, p)
for (j in rep(ix, restore_num))
{
m = mu_e[j]- sum(Omg_e[j,][-j]*(z[-j] - mu_e[-j]))/Omg_e[j,j]
v = sqrt(1/Omg_e[j,j])
if (j_c == 1) b = Inf else b = z[ix[j_c-1]]
if (j_c == p) a = -Inf else a = z[ix[j_c+1]]
tz = rtruncnorm(1, a=a, b=b, mean = m, sd = v)
z[j] = tz
j_c = j_c + 1
if (j_c>p)
{
zmat[j_k,] = z
j_c = 1
j_k = j_k + 1
}
}
colMeans(zmat)
boxplot(zmat)
rm(list = ls()); gc()
library(MASS)
if (!require(truncnorm)) {install.packages("truncnorm") ; library(truncnorm)}
p = 5
mu = seq(5,0, length = p)
Sigma = diag(1,p)
n = 100
verbose = T
set.seed(1)
z = mvrnorm(n, mu, Sigma)
# pi_mat denotes the ranks of items
pi_mat =t(apply(z, 1, order, decreasing = T))
n = nrow(pi_mat)
n
rank_index_t = c("", n)
# pi_mat denotes the ranks of items
pi_mat =t(apply(z, 1, order, decreasing = T))
pi_mat
(class(pi_mat)!='matrix' | class(pi_mat)!='list')
(class(pi_mat)!='matrix' & class(pi_mat)!='list')
if (class(pi_mat)='matrix')
{
n = nrow(pi_mat)
p = ncol(pi_mat)
}
if (class(pi_mat)='list') n = length(pi_mat)
if (class(pi_mat)=='matrix')
{
n = nrow(pi_mat)
p = ncol(pi_mat)
}
if (class(pi_mat)=='list') n = length(pi_mat)
rank_index_t = c("", n)
for (i in 1:n)
{
x = pi_mat[i,]
if (p<10)
{
xt = as.character(x)
rank_index_t[i] = paste(xt,sep='',collapse = "")
}
if (p>=10)
{
xt = x
idx = (nchar(xt)==1)
xt[idx] = paste0("0",xt[idx])
rank_index_t[i] = paste(xt,sep='',collapse = "")
}
}
rank_index_t = factor(rank_index_t)
rank_id = levels(rank_index_t)
rank_index = as.integer(rank_index_t)
rankIndex_fun = function(pi_mat)
{
if (class(pi_mat)!='matrix' & class(pi_mat)!='list')
{
stop("pi_mat should be matrix or list!")
}
if (class(pi_mat)=='matrix')
{
n = nrow(pi_mat)
p = ncol(pi_mat)
}
if (class(pi_mat)=='list') n = length(pi_mat)
rank_index_t = c("", n)
for (i in 1:n)
{
x = pi_mat[i,]
if (p<10)
{
xt = as.character(x)
rank_index_t[i] = paste(xt,sep='',collapse = "")
}
if (p>=10)
{
xt = x
idx = (nchar(xt)==1)
xt[idx] = paste0("0",xt[idx])
rank_index_t[i] = paste(xt,sep='',collapse = "")
}
}
rank_index_t = factor(rank_index_t)
rank_id = levels(rank_index_t)
rank_index = as.integer(rank_index_t)
return(list(rank_id = rank_id, rank_index = rank_index))
}
rankIndex_fun(pi_mat)
library(./lib/conv.R)
rm(list = ls()); gc()
library(MASS)
setwd("~/GitHub/MLE_Thurstone")
if (!require(truncnorm)) {install.packages("truncnorm") ; library(truncnorm)}
library(./lib/conv.R)
getwd()
source(./lib/conv.R)
source("./lib/conv.R")
p = 5
mu = seq(5,0, length = p)
Sigma = diag(1,p)
n = 100
verbose = T
set.seed(1)
z = mvrnorm(n, mu, Sigma)
# pi_mat denotes the ranks of items
pi_mat =t(apply(z, 1, order, decreasing = T))
rankIndex_list = rankIndex_fun(pi_mat)
rank_id = rankIndex_list$rank_id
rank_index = rankIndex_list$rank_index
