rm(list = ls()); gc()
library(MASS)
if (Sys.info()[1]=="Linux")
{
setwd("~/Documents/GitHub/MLE_Thurstone")
} else {
setwd("~/GitHub/MLE_Thurstone")
}
if (!require(truncnorm)) {install.packages("truncnorm") ; library(truncnorm)}
source("./lib/conv.R")
source("./lib/em_lib.R")
p = 5
mu = seq(5,0, length = p)
Sigma = matrix(0.5, p, p)
Sigma[,p] =  Sigma[p,] = 0
diag(Sigma) = 1
n = 100
burn_num = 1e+2
restore_num = 5e+4
verbose = F
#set.seed(1)
z = mvrnorm(n, mu, Sigma)
# pi_mat denotes the index of items
# pi_mat[i,k]: the index of item with rank k in the ith experi
pi_mat =t(apply(z, 1, order, decreasing = T))
rankIndex_list = rankIndex_fun(pi_mat)
pi_mat
rankIndex_list
pi_mat
if (class(pi_mat)!='matrix' & class(pi_mat)!='list')
{
stop("pi_mat should be matrix or list!")
}
if (class(pi_mat)=='matrix')
{
n = nrow(pi_mat)
p = ncol(pi_mat)
}
if (class(pi_mat)=='list') n = length(pi_mat)
rank_index_t = c("", n)
for (i in 1:n)
{
x = pi_mat[i,]
if (p<10)
{
xt = as.character(x)
rank_index_t[i] = paste(xt,sep='',collapse = "")
}
if (p>=10)
{
xt = x
idx = (nchar(xt)==1)
xt[idx] = paste0("0",xt[idx])
rank_index_t[i] = paste(xt,sep='',collapse = "")
}
}
rank_index_t
factor(rank_index_t)
rank_index_t = factor(rank_index_t)
rank_index_t
tabke(rank_index_t)
table(rank_index_t)
prob.table(table(rank_index_t))
rank_index_t
table(rank_index_t)
table(rank_index_t)/n
freq_v= table(rank_index_t)/n
freq_v = table(rank_index_t)/n
rank_id = levels(rank_index_t)
rank_id
rank_index = as.integer(rank_index_t)
rank_index
return(list(rank_id = rank_id, rank_index = rank_index,
freq_v = freq_v))
# rankIndex_fun
# input: obs of rankings, pi_mat[i,j] denotes the rank of the jth item in the ith experiment
# output: rank_id(set of the unique ranks),
#         rank_index[i]; type of ranks in rank_id in the ith experiment
rankIndex_fun = function(pi_mat)
{
if (class(pi_mat)!='matrix' & class(pi_mat)!='list')
{
stop("pi_mat should be matrix or list!")
}
if (class(pi_mat)=='matrix')
{
n = nrow(pi_mat)
p = ncol(pi_mat)
}
if (class(pi_mat)=='list') n = length(pi_mat)
rank_index_t = c("", n)
for (i in 1:n)
{
x = pi_mat[i,]
if (p<10)
{
xt = as.character(x)
rank_index_t[i] = paste(xt,sep='',collapse = "")
}
if (p>=10)
{
xt = x
idx = (nchar(xt)==1)
xt[idx] = paste0("0",xt[idx])
rank_index_t[i] = paste(xt,sep='',collapse = "")
}
}
rank_index_t = factor(rank_index_t)
freq_v = table(rank_index_t)/n
rank_id = levels(rank_index_t)
rank_index = as.integer(rank_index_t)
return(list(rank_id = rank_id, rank_index = rank_index,
freq_v = freq_v))
}
rm(list = ls()); gc()
library(MASS)
if (Sys.info()[1]=="Linux")
{
setwd("~/Documents/GitHub/MLE_Thurstone")
} else {
setwd("~/GitHub/MLE_Thurstone")
}
if (!require(truncnorm)) {install.packages("truncnorm") ; library(truncnorm)}
source("./lib/conv.R")
source("./lib/em_lib.R")
p = 5
mu = seq(5,0, length = p)
Sigma = matrix(0.5, p, p)
Sigma[,p] =  Sigma[p,] = 0
diag(Sigma) = 1
n = 100
burn_num = 1e+2
restore_num = 5e+4
verbose = F
#set.seed(1)
z = mvrnorm(n, mu, Sigma)
# pi_mat denotes the index of items
# pi_mat[i,k]: the index of item with rank k in the ith experi
pi_mat =t(apply(z, 1, order, decreasing = T))
rankIndex_list = rankIndex_fun(pi_mat)
rankIndex_list
# initialization:: pairwise comparisons (package)
fit_mat = convToMat_fun(pi_mat)
fit_mat
d_mat = genDesignR_fun(p)
wvec = convToW_fun(fit_mat)
fit_model = glm.fit(x = d_mat$x, y=d_mat$y,
weight = wvec, family = binomial(link='probit'),
intercept = FALSE)
fit_model
# Note: ignore warning:In eval(family$initialize)
mu_e = c(fit_model$coefficients*sqrt(2),0) # note: probit reg z~N(0, 1/sqrt(2))
Sig_e = diag(1,p)
Omg_e = solve(Sig_e)
cat("outer iter:", iter ,'\n')
