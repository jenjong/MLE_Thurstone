{
p = ncol(pi_mat)
rank_id = rankIndex_list$rank_id
rank_index = rankIndex_list$rank_index
zmat_mean = matrix(0,length(rank_id),p)
for (i in 1:length(rank_id))
{
#
if (verbose) cat("#iter:", i, "  ")
idx = which(rank_index == i)
x = pi_mat[idx[1],]
# set an initial of z
while(T)
{
z = mvrnorm(1, mu_e, Sig_e)
zo = order(z, decreasing = T)
if (!any(x != zo))
{
if (verbose) cat("Initialization is complete!\n ")
break
}
}
# burning
# ix[j_c] : the index of item with rank j_c
# iterates according to ranks (j_c from 1 to p)
j_c = 1
for (j in rep(x, burn_num))
{
m = mu_e[j]- sum(Omg_e[j,][-j]*(z[-j] - mu_e[-j]))/Omg_e[j,j]
v = sqrt(1/Omg_e[j,j])
if (j_c == 1) b = Inf else b = z[x[j_c-1]]
if (j_c == p) a = -Inf else a = z[x[j_c+1]]
if (a>=b) stop("error 1")
z[j] = rtruncnorm(1, a=a, b=b, mean = m, sd = v)
if (is.na(z[j])) stop("NA occurs")
j_c = j_c + 1
if (j_c>p) j_c = 1
}
# restore
j_k = 1
j_c = 1
zmat = matrix(0, restore_num, p)
for (j in rep(x, restore_num))
{
m = mu_e[j]- sum(Omg_e[j,][-j]*(z[-j] - mu_e[-j]))/Omg_e[j,j]
v = sqrt(1/Omg_e[j,j])
if (j_c == 1) b = Inf else b = z[x[j_c-1]]
if (j_c == p) a = -Inf else a = z[x[j_c+1]]
tz = rtruncnorm(1, a=a, b=b, mean = m, sd = v)
z[j] = tz
j_c = j_c + 1
if (j_c>p)
{
zmat[j_k,] = z
j_c = 1
j_k = j_k + 1
}
}
zmat_mean[i,] = colMeans(zmat)
}
return(zmat_mean)
}
rm(list = ls()); gc()
library(MASS)
setwd("~/GitHub/MLE_Thurstone")
if (!require(truncnorm)) {install.packages("truncnorm") ; library(truncnorm)}
source("./lib/conv.R")
p = 5
mu = seq(5,0, length = p)
Sigma = diag(1,p)
n = 200
burn_num = 1e+3
restore_num = 5e+3
verbose = T
#set.seed(1)
z = mvrnorm(n, mu, Sigma)
# pi_mat denotes the index of items
# pi_mat[i,k]: the index of item with rank k in the ith experi
pi_mat =t(apply(z, 1, order, decreasing = T))
rankIndex_list = rankIndex_fun(pi_mat)
# initialization:: pairwise comparisons (package)
fit_mat = convToMat_fun(pi_mat)
d_mat = genDesignR_fun(p)
wvec = convToW_fun(fit_mat)
fit_model = glm.fit(x = d_mat$x, y=d_mat$y,
weight = wvec, family = binomial(link='probit'),
intercept = FALSE)
# Note: ignore warning:In eval(family$initialize)
mu_e = c(fit_model$coefficients*sqrt(2),0) # note: probit reg z~N(0, 1/sqrt(2))
Sig_e = diag(1,p)
Omg_e = solve(Sig_e)
# sampling function
E.prob = E_fun.prob(rankIndex_list,
burn_num, restore_num, verbose)
rm(list = ls()); gc()
library(MASS)
setwd("~/GitHub/MLE_Thurstone")
if (!require(truncnorm)) {install.packages("truncnorm") ; library(truncnorm)}
source("./lib/conv.R")
source("./lib/em_lib.R")
p = 5
mu = seq(5,0, length = p)
Sigma = diag(1,p)
n = 200
burn_num = 1e+3
restore_num = 5e+3
verbose = T
#set.seed(1)
z = mvrnorm(n, mu, Sigma)
# pi_mat denotes the index of items
# pi_mat[i,k]: the index of item with rank k in the ith experi
pi_mat =t(apply(z, 1, order, decreasing = T))
rankIndex_list = rankIndex_fun(pi_mat)
# initialization:: pairwise comparisons (package)
fit_mat = convToMat_fun(pi_mat)
d_mat = genDesignR_fun(p)
wvec = convToW_fun(fit_mat)
fit_model = glm.fit(x = d_mat$x, y=d_mat$y,
weight = wvec, family = binomial(link='probit'),
intercept = FALSE)
# Note: ignore warning:In eval(family$initialize)
mu_e = c(fit_model$coefficients*sqrt(2),0) # note: probit reg z~N(0, 1/sqrt(2))
Sig_e = diag(1,p)
Omg_e = solve(Sig_e)
# sampling function
E.prob = E_fun.prob(rankIndex_list,
burn_num, restore_num, verbose)
E.prob
p = ncol(pi_mat)
rank_id = rankIndex_list$rank_id
rank_index = rankIndex_list$rank_index
Ez = matrix(0, n, p)
rank_index
i = 1
idx = (rank_index == i)
idx
E.prob[i,]
Ez[idx,] = E.prob[i,]
Ez
Ez = matrix(0, n, p, byrow = T)
idx = (rank_index == i)
Ez[idx,] = E.prob[i,]
Ez
E.prob[i,]
which = (rank_index == i)
idx = which(rank_index == i)
idx
idx
Ez = matrix(0, n, p)
idx = which(rank_index == i)
for (j in idx)
{
Ez[j,] = E.prob[i,]
}
Ez
Ez = matrix(0, n, p)
for (i in 1:length(rank_id))
{
idx = which(rank_index == i)
for (j in idx)
{
Ez[j,] = E.prob[i,]
}
}
Ex
Ez
rm(list = ls()); gc()
library(MASS)
setwd("~/GitHub/MLE_Thurstone")
if (!require(truncnorm)) {install.packages("truncnorm") ; library(truncnorm)}
source("./lib/conv.R")
source("./lib/em_lib.R")
p = 5
mu = seq(5,0, length = p)
Sigma = diag(1,p)
n = 200
burn_num = 1e+3
restore_num = 5e+3
verbose = T
#set.seed(1)
z = mvrnorm(n, mu, Sigma)
# pi_mat denotes the index of items
# pi_mat[i,k]: the index of item with rank k in the ith experi
pi_mat =t(apply(z, 1, order, decreasing = T))
rankIndex_list = rankIndex_fun(pi_mat)
# initialization:: pairwise comparisons (package)
fit_mat = convToMat_fun(pi_mat)
d_mat = genDesignR_fun(p)
wvec = convToW_fun(fit_mat)
fit_model = glm.fit(x = d_mat$x, y=d_mat$y,
weight = wvec, family = binomial(link='probit'),
intercept = FALSE)
# Note: ignore warning:In eval(family$initialize)
mu_e = c(fit_model$coefficients*sqrt(2),0) # note: probit reg z~N(0, 1/sqrt(2))
Sig_e = diag(1,p)
Omg_e = solve(Sig_e)
# sampling function
Ez = E_fun.prob(rankIndex_list,
burn_num, restore_num, verbose)
rm(list = ls()); gc()
library(MASS)
setwd("~/GitHub/MLE_Thurstone")
if (!require(truncnorm)) {install.packages("truncnorm") ; library(truncnorm)}
source("./lib/conv.R")
source("./lib/em_lib.R")
p = 5
mu = seq(5,0, length = p)
Sigma = diag(1,p)
n = 200
burn_num = 1e+3
restore_num = 5e+3
verbose = T
#set.seed(1)
z = mvrnorm(n, mu, Sigma)
# pi_mat denotes the index of items
# pi_mat[i,k]: the index of item with rank k in the ith experi
pi_mat =t(apply(z, 1, order, decreasing = T))
rankIndex_list = rankIndex_fun(pi_mat)
# initialization:: pairwise comparisons (package)
fit_mat = convToMat_fun(pi_mat)
d_mat = genDesignR_fun(p)
wvec = convToW_fun(fit_mat)
fit_model = glm.fit(x = d_mat$x, y=d_mat$y,
weight = wvec, family = binomial(link='probit'),
intercept = FALSE)
# Note: ignore warning:In eval(family$initialize)
mu_e = c(fit_model$coefficients*sqrt(2),0) # note: probit reg z~N(0, 1/sqrt(2))
Sig_e = diag(1,p)
Omg_e = solve(Sig_e)
# sampling function
Ez = E_fun.prob(rankIndex_list,
burn_num, restore_num, verbose)
Ez
rm(list = ls()); gc()
library(MASS)
setwd("~/GitHub/MLE_Thurstone")
if (!require(truncnorm)) {install.packages("truncnorm") ; library(truncnorm)}
source("./lib/conv.R")
source("./lib/em_lib.R")
p = 5
mu = seq(5,0, length = p)
Sigma = diag(1,p)
n = 200
burn_num = 1e+3
restore_num = 5e+3
verbose = T
#set.seed(1)
z = mvrnorm(n, mu, Sigma)
# pi_mat denotes the index of items
# pi_mat[i,k]: the index of item with rank k in the ith experi
pi_mat =t(apply(z, 1, order, decreasing = T))
rankIndex_list = rankIndex_fun(pi_mat)
# initialization:: pairwise comparisons (package)
fit_mat = convToMat_fun(pi_mat)
d_mat = genDesignR_fun(p)
wvec = convToW_fun(fit_mat)
fit_model = glm.fit(x = d_mat$x, y=d_mat$y,
weight = wvec, family = binomial(link='probit'),
intercept = FALSE)
# Note: ignore warning:In eval(family$initialize)
mu_e = c(fit_model$coefficients*sqrt(2),0) # note: probit reg z~N(0, 1/sqrt(2))
Sig_e = diag(1,p)
Omg_e = solve(Sig_e)
# sampling function
Ez = E_fun.prob(rankIndex_list,
burn_num, restore_num, verbose)
rm(list = ls()); gc()
library(MASS)
setwd("~/GitHub/MLE_Thurstone")
if (!require(truncnorm)) {install.packages("truncnorm") ; library(truncnorm)}
source("./lib/conv.R")
source("./lib/em_lib.R")
p = 5
mu = seq(5,0, length = p)
Sigma = diag(1,p)
n = 200
burn_num = 1e+2
restore_num = 5e+3
verbose = T
#set.seed(1)
z = mvrnorm(n, mu, Sigma)
# pi_mat denotes the index of items
# pi_mat[i,k]: the index of item with rank k in the ith experi
pi_mat =t(apply(z, 1, order, decreasing = T))
rankIndex_list = rankIndex_fun(pi_mat)
# initialization:: pairwise comparisons (package)
fit_mat = convToMat_fun(pi_mat)
d_mat = genDesignR_fun(p)
wvec = convToW_fun(fit_mat)
fit_model = glm.fit(x = d_mat$x, y=d_mat$y,
weight = wvec, family = binomial(link='probit'),
intercept = FALSE)
# Note: ignore warning:In eval(family$initialize)
mu_e = c(fit_model$coefficients*sqrt(2),0) # note: probit reg z~N(0, 1/sqrt(2))
Sig_e = diag(1,p)
Omg_e = solve(Sig_e)
# sampling function
Ez = E_fun.prob(rankIndex_list,
burn_num, restore_num, verbose)
Ez
colMean(Ez)
Ez
colMeans(Ez)
mu_e
mu_e = colMeans(Ez)
Sig_e = cov(Ez)
Sig_e
Omg_e = solve(Sig_e)
rm(list = ls()); gc()
library(MASS)
setwd("~/GitHub/MLE_Thurstone")
if (!require(truncnorm)) {install.packages("truncnorm") ; library(truncnorm)}
source("./lib/conv.R")
source("./lib/em_lib.R")
p = 5
mu = seq(5,0, length = p)
Sigma = diag(1,p)
n = 200
burn_num = 1e+2
restore_num = 5e+3
verbose = T
#set.seed(1)
z = mvrnorm(n, mu, Sigma)
# pi_mat denotes the index of items
# pi_mat[i,k]: the index of item with rank k in the ith experi
pi_mat =t(apply(z, 1, order, decreasing = T))
rankIndex_list = rankIndex_fun(pi_mat)
# initialization:: pairwise comparisons (package)
fit_mat = convToMat_fun(pi_mat)
d_mat = genDesignR_fun(p)
wvec = convToW_fun(fit_mat)
fit_model = glm.fit(x = d_mat$x, y=d_mat$y,
weight = wvec, family = binomial(link='probit'),
intercept = FALSE)
# Note: ignore warning:In eval(family$initialize)
mu_e = c(fit_model$coefficients*sqrt(2),0) # note: probit reg z~N(0, 1/sqrt(2))
Sig_e = diag(1,p)
Omg_e = solve(Sig_e)
# sampling function
Ez = E_fun.prob(rankIndex_list, mu_e, Omg_e,
burn_num, restore_num, verbose)
mu_e = colMeans(Ez)
Sig_e = cov(Ez)
Omg_e = solve(Sig_e)
mu_e
Sig_e
Omg_e = solve(Sig_e)
Omg_e
Omg_e
# Note: ignore warning:In eval(family$initialize)
mu_e = c(fit_model$coefficients*sqrt(2),0) # note: probit reg z~N(0, 1/sqrt(2))
mu_e
Sigma
Ez = E_fun.prob(rankIndex_list, mu_e, Omg_e,
burn_num, restore_num, verbose)
rankIndex_list$rank_id[18]
mu
rm(list = ls()); gc()
library(MASS)
setwd("~/GitHub/MLE_Thurstone")
if (!require(truncnorm)) {install.packages("truncnorm") ; library(truncnorm)}
source("./lib/conv.R")
source("./lib/em_lib.R")
p = 4
mu = seq(5,0, length = p)
Sigma = diag(1,p)
n = 2000
burn_num = 1e+2
restore_num = 5e+3
verbose = T
#set.seed(1)
z = mvrnorm(n, mu, Sigma)
# pi_mat denotes the index of items
# pi_mat[i,k]: the index of item with rank k in the ith experi
pi_mat =t(apply(z, 1, order, decreasing = T))
rankIndex_list = rankIndex_fun(pi_mat)
# initialization:: pairwise comparisons (package)
fit_mat = convToMat_fun(pi_mat)
d_mat = genDesignR_fun(p)
wvec = convToW_fun(fit_mat)
fit_model = glm.fit(x = d_mat$x, y=d_mat$y,
weight = wvec, family = binomial(link='probit'),
intercept = FALSE)
# Note: ignore warning:In eval(family$initialize)
mu_e = c(fit_model$coefficients*sqrt(2),0) # note: probit reg z~N(0, 1/sqrt(2))
Sig_e = diag(1,p)
Omg_e = solve(Sig_e)
# sampling function
Ez = E_fun.prob(rankIndex_list, mu_e, Omg_e,
burn_num, restore_num, verbose)
mu_e = colMeans(Ez)
Sig_e = cov(Ez)
Omg_e = solve(Sig_e)
mu_e
Sig_e
Omg_e = solve(Sig_e)
Omg_e
Ez = E_fun.prob(rankIndex_list, mu_e, Omg_e,
burn_num, restore_num, verbose)
rm(list = ls()); gc()
library(MASS)
setwd("~/GitHub/MLE_Thurstone")
if (!require(truncnorm)) {install.packages("truncnorm") ; library(truncnorm)}
source("./lib/conv.R")
source("./lib/em_lib.R")
p = 4
mu = seq(5,0, length = p)
Sigma = diag(1,p)
n = 2000
burn_num = 1e+2
restore_num = 5e+3
verbose = T
#set.seed(1)
z = mvrnorm(n, mu, Sigma)
# pi_mat denotes the index of items
# pi_mat[i,k]: the index of item with rank k in the ith experi
pi_mat =t(apply(z, 1, order, decreasing = T))
rankIndex_list = rankIndex_fun(pi_mat)
# initialization:: pairwise comparisons (package)
fit_mat = convToMat_fun(pi_mat)
d_mat = genDesignR_fun(p)
wvec = convToW_fun(fit_mat)
fit_model = glm.fit(x = d_mat$x, y=d_mat$y,
weight = wvec, family = binomial(link='probit'),
intercept = FALSE)
# Note: ignore warning:In eval(family$initialize)
mu_e = c(fit_model$coefficients*sqrt(2),0) # note: probit reg z~N(0, 1/sqrt(2))
Sig_e = diag(1,p)
Omg_e = solve(Sig_e)
# sampling function
Ez = E_fun.prob(rankIndex_list, mu_e, Omg_e,
burn_num, restore_num, verbose)
mu_e = colMeans(Ez)
Sig_e = cov(Ez)
Omg_e = solve(Sig_e)
Sig_e
rm(list = ls()); gc()
library(MASS)
setwd("~/GitHub/MLE_Thurstone")
if (!require(truncnorm)) {install.packages("truncnorm") ; library(truncnorm)}
source("./lib/conv.R")
source("./lib/em_lib.R")
p = 4
mu = seq(5,0, length = p)
Sigma = diag(1,p)
n = 100
burn_num = 1e+2
restore_num = 5e+3
verbose = T
#set.seed(1)
z = mvrnorm(n, mu, Sigma)
# pi_mat denotes the index of items
# pi_mat[i,k]: the index of item with rank k in the ith experi
pi_mat =t(apply(z, 1, order, decreasing = T))
rankIndex_list = rankIndex_fun(pi_mat)
# initialization:: pairwise comparisons (package)
fit_mat = convToMat_fun(pi_mat)
d_mat = genDesignR_fun(p)
wvec = convToW_fun(fit_mat)
fit_model = glm.fit(x = d_mat$x, y=d_mat$y,
weight = wvec, family = binomial(link='probit'),
intercept = FALSE)
# Note: ignore warning:In eval(family$initialize)
mu_e = c(fit_model$coefficients*sqrt(2),0) # note: probit reg z~N(0, 1/sqrt(2))
Sig_e = diag(1,p)
Omg_e = solve(Sig_e)
# sampling function
Ez = E_fun.prob(rankIndex_list, mu_e, Omg_e,
burn_num, restore_num, verbose)
mu_e = colMeans(Ez)
Sig_e = cov(Ez)
Omg_e = solve(Sig_e)
Sig_e
mu_e
Sig_e
rm(list = ls()); gc()
library(MASS)
setwd("~/GitHub/MLE_Thurstone")
if (!require(truncnorm)) {install.packages("truncnorm") ; library(truncnorm)}
source("./lib/conv.R")
source("./lib/em_lib.R")
p = 4
mu = seq(5,0, length = p)
Sigma = diag(1,p)
n = 10000
burn_num = 1e+2
restore_num = 5e+3
verbose = T
#set.seed(1)
z = mvrnorm(n, mu, Sigma)
# pi_mat denotes the index of items
# pi_mat[i,k]: the index of item with rank k in the ith experi
pi_mat =t(apply(z, 1, order, decreasing = T))
rankIndex_list = rankIndex_fun(pi_mat)
# initialization:: pairwise comparisons (package)
fit_mat = convToMat_fun(pi_mat)
d_mat = genDesignR_fun(p)
wvec = convToW_fun(fit_mat)
fit_model = glm.fit(x = d_mat$x, y=d_mat$y,
weight = wvec, family = binomial(link='probit'),
intercept = FALSE)
# Note: ignore warning:In eval(family$initialize)
mu_e = c(fit_model$coefficients*sqrt(2),0) # note: probit reg z~N(0, 1/sqrt(2))
Sig_e = diag(1,p)
Omg_e = solve(Sig_e)
# sampling function
Ez = E_fun.prob(rankIndex_list, mu_e, Omg_e,
burn_num, restore_num, verbose)
mu_e = colMeans(Ez)
Sig_e = cov(Ez)
Omg_e = solve(Sig_e)
Sig_e
