rank_index = rankIndex_list$rank_index
pi_mat
i = 1
z = pi_mat[i,]
z
Nmat = matrix(0,p,p)
Wmat = matrix(0,p,p)
for (i in 1:nrow(pi_mat))
{
z = pi_mat[i,]
for (j in 1:(length(z)-1))
{
for (k in (j+1):length(z))
{
ix1 = z[j] ; ix2 = z[k]
Nmat[ix1,ix2] = Nmat[ix2,ix1] = Nmat[ix1,ix2] + 1
Wmat[ix1,ix2] = Wmat[ix1,ix2] + 1
}
}
}
Nmat
Wmat
library(MASS)
?glm
library(glmnet)
?glmnet
?`glm
?glm
Gmat
# convToW_fun
# input
p =
wmat = Qpmat*Gmat_hat
Gmat_hat
Wmat
Nmat
Wmat
Wmat/Nmat
Gmat_hat = Wmat/Nmat
Gmat_hat[Nmat==0] = 0
Gmat_hat
Gmat_hat[Nmat==0] = 0
Qpmat = Nmat/sum(Nmat)
Qpmat
convToMat_fun = function(pi_mat)
{
p = ncol(pi_mat)
n = nrow(pi_mat)
Nmat = matrix(0,p,p)
Wmat = matrix(0,p,p)
for (i in 1:nrow(pi_mat))
{
z = pi_mat[i,]
for (j in 1:(length(z)-1))
{
for (k in (j+1):length(z))
{
ix1 = z[j] ; ix2 = z[k]
Nmat[ix1,ix2] = Nmat[ix2,ix1] = Nmat[ix1,ix2] + 1
Wmat[ix1,ix2] = Wmat[ix1,ix2] + 1
}
}
}
Gmat_hat = Wmat/Nmat
Gmat_hat[Nmat==0] = 0
Qpmat = Nmat/sum(Nmat)
return(list(Gmat_hat=Gmat_hat, Qpmat=Qpmat))
}
source("./lib/conv.R")
# initialization:: pairwise comparisons (package)
convToMat_fun(pi_mat)
# initialization:: pairwise comparisons (package)
fit_mat = convToMat_fun(pi_mat)
Gmat_hat = fit_mat$Gmat_hat
p = ncol(Qpmat)
wmat = Qpmat*Gmat_hat
wmat = t(wmat)
wvec = wmat[ - (1 + ( 0:(p-1) ) *(p+1))]
wvec
?glm.fit
design_mat = genDesignR_fun(p)
design_mat
convToW_fun = function(fit_mat)
{
Qpmat = fit_mat$Qpmat
Gmat_hat = fit_mat$Gmat_hat
p = ncol(Qpmat)
wmat = Qpmat*Gmat_hat
wmat = t(wmat)
wvec = wmat[ - (1 + ( 0:(p-1) ) *(p+1))]
return(wvec)
}
wvec = convToW_fun(fit_mat)
wvec
design_mat
d_mat = genDesignR_fun(p)
d_mat
glm.fit(x = d_mat$x, y=d_mat$y, weight = wvec)
glm.fit(x = d_mat$x, y=d_mat$y, weight = wvec, family = binomial(link='probit'))
glm.fit(x = d_mat$x, y=d_mat$y,
weight = wvec, family = binomial(link='probit'))
glm.fit(x = d_mat$x, y=d_mat$y,
weight = wvec, family = binomial(link='probit'),
intercept = FALSE)
fit_model = glm.fit(x = d_mat$x, y=d_mat$y,
weight = wvec, family = binomial(link='probit'),
intercept = FALSE)
fit_model$coefficients
fit_model$weights
fit_model = glm.fit(x = d_mat$x, y=d_mat$y,
weight = trunc(wvec*1000), family = binomial(link='probit'),
intercept = FALSE)
fit_model$coefficients
fit_model = glm.fit(x = d_mat$x, y=d_mat$y,
weight = trunc(wvec*10000), family = binomial(link='probit'),
intercept = FALSE)
fit_model$coefficients
wvec
fit_model = glm.fit(x = d_mat$x, y=d_mat$y,
weight = wvec, family = binomial(link='probit'),
intercept = FALSE)
fit_model$coefficients
fit_model = glm.fit(x = d_mat$x, y=d_mat$y,
weight = wvec, family = binomial(link='probit'),
intercept = FALSE)
fit_model = glm.fit(x = d_mat$x, y=d_mat$y,
weight = round(wvec*1+5e), family = binomial(link='probit'),
intercept = FALSE)
round(wvec*1+5e)
round(wvec*1e+5)
fit_model = glm.fit(x = d_mat$x, y=d_mat$y,
weight = round(wvec*1e+6), family = binomial(link='probit'),
intercept = FALSE)
fit_model = glm.fit(x = d_mat$x, y=d_mat$y,
weight = round(wvec*1e+6), family = binomial(link='probit'),
intercept = FALSE)
fit_model$coefficients
fit_model = glm.fit(x = d_mat$x, y=d_mat$y,
weight = wvec, family = binomial(link='probit'),
intercept = FALSE)
mu_e = fit_model$coefficients
mu_e
rm(list = ls()); gc()
library(MASS)
setwd("~/GitHub/MLE_Thurstone")
if (!require(truncnorm)) {install.packages("truncnorm") ; library(truncnorm)}
source("./lib/conv.R")
p = 5
mu = seq(5,0, length = p)
Sigma = diag(1,p)
n = 200
verbose = T
set.seed(1)
z = mvrnorm(n, mu, Sigma)
# pi_mat denotes the ranks of items
pi_mat =t(apply(z, 1, order, decreasing = T))
rankIndex_list = rankIndex_fun(pi_mat)
rank_id = rankIndex_list$rank_id
rank_index = rankIndex_list$rank_index
# initialization:: pairwise comparisons (package)
fit_mat = convToMat_fun(pi_mat)
d_mat = genDesignR_fun(p)
wvec = convToW_fun(fit_mat)
fit_model = glm.fit(x = d_mat$x, y=d_mat$y,
weight = wvec, family = binomial(link='probit'),
intercept = FALSE)
mu_e = fit_model$coefficients
mu_e
rm(list = ls()); gc()
library(MASS)
setwd("~/GitHub/MLE_Thurstone")
if (!require(truncnorm)) {install.packages("truncnorm") ; library(truncnorm)}
source("./lib/conv.R")
p = 5
mu = seq(5,0, length = p)
Sigma = diag(1,p)
n = 200
verbose = T
#set.seed(1)
z = mvrnorm(n, mu, Sigma)
# pi_mat denotes the ranks of items
pi_mat =t(apply(z, 1, order, decreasing = T))
rankIndex_list = rankIndex_fun(pi_mat)
rank_id = rankIndex_list$rank_id
rank_index = rankIndex_list$rank_index
# initialization:: pairwise comparisons (package)
fit_mat = convToMat_fun(pi_mat)
d_mat = genDesignR_fun(p)
wvec = convToW_fun(fit_mat)
fit_model = glm.fit(x = d_mat$x, y=d_mat$y,
weight = wvec, family = binomial(link='probit'),
intercept = FALSE)
mu_e = fit_model$coefficients
mu_e
rm(list = ls()); gc()
library(MASS)
setwd("~/GitHub/MLE_Thurstone")
if (!require(truncnorm)) {install.packages("truncnorm") ; library(truncnorm)}
source("./lib/conv.R")
p = 5
mu = seq(5,0, length = p)
Sigma = diag(1,p)
n = 2000
verbose = T
#set.seed(1)
z = mvrnorm(n, mu, Sigma)
# pi_mat denotes the ranks of items
pi_mat =t(apply(z, 1, order, decreasing = T))
rankIndex_list = rankIndex_fun(pi_mat)
rank_id = rankIndex_list$rank_id
rank_index = rankIndex_list$rank_index
# initialization:: pairwise comparisons (package)
fit_mat = convToMat_fun(pi_mat)
d_mat = genDesignR_fun(p)
wvec = convToW_fun(fit_mat)
fit_model = glm.fit(x = d_mat$x, y=d_mat$y,
weight = wvec, family = binomial(link='probit'),
intercept = FALSE)
mu_e = fit_model$coefficients
mu_e
rm(list = ls()); gc()
library(MASS)
setwd("~/GitHub/MLE_Thurstone")
if (!require(truncnorm)) {install.packages("truncnorm") ; library(truncnorm)}
source("./lib/conv.R")
p = 5
mu = seq(5,0, length = p)
Sigma = diag(1,p)
n = 10000
verbose = T
#set.seed(1)
z = mvrnorm(n, mu, Sigma)
# pi_mat denotes the ranks of items
pi_mat =t(apply(z, 1, order, decreasing = T))
rankIndex_list = rankIndex_fun(pi_mat)
rank_id = rankIndex_list$rank_id
rank_index = rankIndex_list$rank_index
# initialization:: pairwise comparisons (package)
fit_mat = convToMat_fun(pi_mat)
d_mat = genDesignR_fun(p)
wvec = convToW_fun(fit_mat)
fit_model = glm.fit(x = d_mat$x, y=d_mat$y,
weight = wvec, family = binomial(link='probit'),
intercept = FALSE)
mu_e = fit_model$coefficients
mu_e
mu_e*sqrt(2)
mu_e = fit_model$coefficients*sqrt(2) # note: probit reg z~N(0, 1/sqrt(2))
mu_e
rm(list = ls()); gc()
library(MASS)
setwd("~/GitHub/MLE_Thurstone")
if (!require(truncnorm)) {install.packages("truncnorm") ; library(truncnorm)}
source("./lib/conv.R")
p = 5
mu = seq(5,0, length = p)
Sigma = diag(1,p)
n = 100
verbose = T
#set.seed(1)
z = mvrnorm(n, mu, Sigma)
# pi_mat denotes the ranks of items
pi_mat =t(apply(z, 1, order, decreasing = T))
rankIndex_list = rankIndex_fun(pi_mat)
rank_id = rankIndex_list$rank_id
rank_index = rankIndex_list$rank_index
# initialization:: pairwise comparisons (package)
fit_mat = convToMat_fun(pi_mat)
d_mat = genDesignR_fun(p)
wvec = convToW_fun(fit_mat)
#
fit_model = glm.fit(x = d_mat$x, y=d_mat$y,
weight = wvec, family = binomial(link='probit'),
intercept = FALSE)
mu_e = fit_model$coefficients*sqrt(2) # note: probit reg z~N(0, 1/sqrt(2))
mu_e
mu
rm(list = ls()); gc()
library(MASS)
setwd("~/GitHub/MLE_Thurstone")
if (!require(truncnorm)) {install.packages("truncnorm") ; library(truncnorm)}
source("./lib/conv.R")
p = 5
mu = seq(5,0, length = p)
Sigma = diag(1,p)
n = 1000
verbose = T
#set.seed(1)
z = mvrnorm(n, mu, Sigma)
# pi_mat denotes the ranks of items
pi_mat =t(apply(z, 1, order, decreasing = T))
rankIndex_list = rankIndex_fun(pi_mat)
rank_id = rankIndex_list$rank_id
rank_index = rankIndex_list$rank_index
# initialization:: pairwise comparisons (package)
fit_mat = convToMat_fun(pi_mat)
d_mat = genDesignR_fun(p)
wvec = convToW_fun(fit_mat)
#
fit_model = glm.fit(x = d_mat$x, y=d_mat$y,
weight = wvec, family = binomial(link='probit'),
intercept = FALSE)
mu_e = fit_model$coefficients*sqrt(2) # note: probit reg z~N(0, 1/sqrt(2))
mu_e
?glm.fit
glm.fit
mu_e
mu
mu
rm(list = ls()); gc()
library(MASS)
setwd("~/GitHub/MLE_Thurstone")
if (!require(truncnorm)) {install.packages("truncnorm") ; library(truncnorm)}
source("./lib/conv.R")
p = 5
mu = seq(5,0, length = p)
Sigma = diag(1,p)
n = 1000
verbose = T
#set.seed(1)
z = mvrnorm(n, mu, Sigma)
# pi_mat denotes the ranks of items
pi_mat =t(apply(z, 1, order, decreasing = T))
rankIndex_list = rankIndex_fun(pi_mat)
rank_id = rankIndex_list$rank_id
rank_index = rankIndex_list$rank_index
# initialization:: pairwise comparisons (package)
fit_mat = convToMat_fun(pi_mat)
d_mat = genDesignR_fun(p)
wvec = convToW_fun(fit_mat)
#
fit_model = glm.fit(x = d_mat$x, y=d_mat$y,
weight = wvec, family = binomial(link='probit'),
intercept = FALSE)
mu_e = fit_model$coefficients*sqrt(2) # note: probit reg z~N(0, 1/sqrt(2))
mu_e
mu
rm(list = ls()); gc()
library(MASS)
setwd("~/GitHub/MLE_Thurstone")
if (!require(truncnorm)) {install.packages("truncnorm") ; library(truncnorm)}
source("./lib/conv.R")
p = 5
mu = seq(5,0, length = p)
Sigma = diag(1,p)
n = 1000
verbose = T
#set.seed(1)
z = mvrnorm(n, mu, Sigma)
# pi_mat denotes the ranks of items
pi_mat =t(apply(z, 1, order, decreasing = T))
rankIndex_list = rankIndex_fun(pi_mat)
rank_id = rankIndex_list$rank_id
rank_index = rankIndex_list$rank_index
# initialization:: pairwise comparisons (package)
fit_mat = convToMat_fun(pi_mat)
d_mat = genDesignR_fun(p)
wvec = convToW_fun(fit_mat)
#
fit_model = glm.fit(x = d_mat$x, y=d_mat$y,
weight = wvec, family = binomial(link='probit'),
intercept = FALSE)
mu_e = fit_model$coefficients*sqrt(2) # note: probit reg z~N(0, 1/sqrt(2))
mu_e
mu
rm(list = ls()); gc()
library(MASS)
setwd("~/GitHub/MLE_Thurstone")
if (!require(truncnorm)) {install.packages("truncnorm") ; library(truncnorm)}
source("./lib/conv.R")
p = 5
mu = seq(5,0, length = p)
Sigma = diag(1,p)
n = 1000
verbose = T
#set.seed(1)
z = mvrnorm(n, mu, Sigma)
# pi_mat denotes the ranks of items
pi_mat =t(apply(z, 1, order, decreasing = T))
rankIndex_list = rankIndex_fun(pi_mat)
rank_id = rankIndex_list$rank_id
rank_index = rankIndex_list$rank_index
# initialization:: pairwise comparisons (package)
fit_mat = convToMat_fun(pi_mat)
d_mat = genDesignR_fun(p)
wvec = convToW_fun(fit_mat)
#
fit_model = glm.fit(x = d_mat$x, y=d_mat$y,
weight = wvec, family = binomial(link='probit'),
intercept = FALSE)
mu_e = fit_model$coefficients*sqrt(2) # note: probit reg z~N(0, 1/sqrt(2))
mu_e
mu
mu_e = c(fit_model$coefficients*sqrt(2),0) # note: probit reg z~N(0, 1/sqrt(2))
mu_e
mu
mu_e = c(fit_model$coefficients*sqrt(2),0) # note: probit reg z~N(0, 1/sqrt(2))
Sig_e = diag(1,p)
Omg_e = solve(Sig_e)
# sampling
i = 1 ; length(rank_id)
mu_e = c(fit_model$coefficients*sqrt(2),0) # note: probit reg z~N(0, 1/sqrt(2))
Sig_e = diag(1,p)
Omg_e = solve(Sig_e)
# sampling function
i = 1 ; length(rank_id)
idx = which(rank_index == i)
x = pi_mat[idx[1],]
# set an initial of z
while(T)
{
z = mvrnorm(1, mu_e, Sig_e)
zo = order(z, decreasing = T)
if (!any(x != zo))
{
if (verbose) cat("Initialization is complete! ")
break
}
}
burn_num = 1e+4
restore_num = 5e+3
# burning
# ix[j_c] : the index of item with rank j_c
# iterates according to ranks (j_c from 1 to p)
j_c = 1
ix = sort(x, index.return = T)$ix
for (j in rep(ix, burn_num))
{
m = mu_e[j]- sum(Omg_e[j,][-j]*(z[-j] - mu_e[-j]))/Omg_e[j,j]
v = sqrt(1/Omg_e[j,j])
if (j_c == 1) b = Inf else b = z[ix[j_c-1]]
if (j_c == p) a = -Inf else a = z[ix[j_c+1]]
z[j] = rtruncnorm(1, a=a, b=b, mean = m, sd = v)
j_c = j_c + 1
if (j_c>p) j_c = 1
}
# restore
j_k = 1
j_c = 1
zmat = matrix(0, restore_num, p)
for (j in rep(ix, restore_num))
{
m = mu_e[j]- sum(Omg_e[j,][-j]*(z[-j] - mu_e[-j]))/Omg_e[j,j]
v = sqrt(1/Omg_e[j,j])
if (j_c == 1) b = Inf else b = z[ix[j_c-1]]
if (j_c == p) a = -Inf else a = z[ix[j_c+1]]
tz = rtruncnorm(1, a=a, b=b, mean = m, sd = v)
z[j] = tz
j_c = j_c + 1
if (j_c>p)
{
zmat[j_k,] = z
j_c = 1
j_k = j_k + 1
}
}
colMeans(zmat)
boxplot(zmat)
mu_e
i = 2 ; length(rank_id)
idx = which(rank_index == i)
x = pi_mat[idx[1],]
# set an initial of z
while(T)
{
z = mvrnorm(1, mu_e, Sig_e)
zo = order(z, decreasing = T)
if (!any(x != zo))
{
if (verbose) cat("Initialization is complete! ")
break
}
}
burn_num = 1e+4
restore_num = 5e+3
# burning
# ix[j_c] : the index of item with rank j_c
# iterates according to ranks (j_c from 1 to p)
j_c = 1
ix = sort(x, index.return = T)$ix
for (j in rep(ix, burn_num))
{
m = mu_e[j]- sum(Omg_e[j,][-j]*(z[-j] - mu_e[-j]))/Omg_e[j,j]
v = sqrt(1/Omg_e[j,j])
if (j_c == 1) b = Inf else b = z[ix[j_c-1]]
if (j_c == p) a = -Inf else a = z[ix[j_c+1]]
z[j] = rtruncnorm(1, a=a, b=b, mean = m, sd = v)
j_c = j_c + 1
if (j_c>p) j_c = 1
}
# restore
j_k = 1
j_c = 1
zmat = matrix(0, restore_num, p)
for (j in rep(ix, restore_num))
{
m = mu_e[j]- sum(Omg_e[j,][-j]*(z[-j] - mu_e[-j]))/Omg_e[j,j]
v = sqrt(1/Omg_e[j,j])
if (j_c == 1) b = Inf else b = z[ix[j_c-1]]
if (j_c == p) a = -Inf else a = z[ix[j_c+1]]
tz = rtruncnorm(1, a=a, b=b, mean = m, sd = v)
z[j] = tz
j_c = j_c + 1
if (j_c>p)
{
zmat[j_k,] = z
j_c = 1
j_k = j_k + 1
}
}
colMeans(zmat)
boxplot(zmat)
